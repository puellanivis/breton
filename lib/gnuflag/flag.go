// Code generated by THIS IS A DERIVATIVE OF OTHER PEOPLES CODE AND golint CANNOT BE TURNED OFF. DO NOT EDIT.
// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

/*	Package gnuflag implements command-line flag parsing compatible with GNU longopts.

	Usage:

	Define flags using flag.String(), Bool(), Int(), etc.

	This declares an integer flag, --flagname, with short flagname -f stored in the pointer ip, with type *int.
		import flag "github.com/puellanivis/breton/lib/gnuflag"
		var ip = flag.Int("flagname", 1234, "help message for flagname", flag.WithShort('f'))
	Or you can create custom flags that satisfy the Value interface (with
	pointer receivers) and couple them to flag parsing by
		flag.Var(&flagVal, "name", "help message for flagname")
	For such flags, the default value is just the initial value of the variable.

	After all flags are defined, call
		flag.Parse()
	to parse the command line into the defined flags.

	Flags may then be used directly. If you're using the flags themselves,
	they are all pointers; if you bind to variables, they're values.
		fmt.Println("ip has value ", *ip)
		fmt.Println("flagvar has value ", flagvar)

	After parsing, the arguments following the flags are available as the
	slice flag.Args() or individually as flag.Arg(i).
	The arguments are indexed from 0 through flag.NArg()-1.

	Command line flag syntax:
		-f    --flag
		-f=x  --flag=x
		-f x  --flag x  // non-boolean flags only
	One minus sign signifies a short flag, while two indicates a long name.
	The last form is not permitted for boolean flags because the
	meaning of the commands
		cmd --flag *
		cmd -f *
	where * is a Unix shell wildcard, will change if there is a file
	called 0, false, etc.  You must use the --flag=false or -f=false
	form to turn off a boolean flag.

	Flag parsing stops just before the first non-flag argument
	("-" is a non-flag argument) or just after the terminator "--".

	Integer flags accept 1234, 0664, 0x1234 and may be negative.
	Boolean flags may be:
		1, 0, t, f, T, F, true, false, TRUE, FALSE, True, False
	Duration flags accept any input valid for time.ParseDuration.

	The default set of command-line flags is controlled by
	top-level functions.  The FlagSet type allows one to define
	independent sets of flags, such as to implement subcommands
	in a command-line interface. The methods of FlagSet are
	analogous to the top-level functions for the command-line
	flag set.
*/
package gnuflag

import (
	"errors"
	"fmt"
	"io"
	"os"
	"reflect"
	"sort"
	"strings"
	"unicode/utf8"
)

// ErrHelp is the error returned if the --help or -? flag is invoked
// but no such flag is defined.
var ErrHelp = errors.New("flag: help requested")

// Value is the interface to the dynamic value stored in a flag.
// (The default value is represented as a string.)
//
// If a Value has an IsBoolFlag() bool method returning true,
// the command-line parser makes --name equivalent to --name=true
// rather than using the next command-line argument.
//
// Additionally, if the flag has a WithShort() alternative, then
// -f is equilvalent to -f=true, and can appear in the non-last
// position of a -shortFlagSeries.
//
// Set is called once, in command line order, for each flag present.
// The flag package may call the String method with a zero-valued receiver,
// such as a nil pointer.
type Value interface {
	String() string

	Set(string) error
	Get() interface{}
}

// ErrorHandling defines how FlagSet.Parse behaves if the parse fails.
type ErrorHandling int

// These constants cause FlagSet.Parse to behave as described if the parse fails.
const (
	ContinueOnError ErrorHandling = iota // Return a descriptive error.
	ExitOnError                          // Call os.Exit(2).
	PanicOnError                         // Call panic with a descriptive error.
)

// A FlagSet represents a set of defined flags. The zero value of a FlagSet
// has no name and has ContinueOnError error handling.
type FlagSet struct {
	// Usage is the function called when an error occurs while parsing flags.
	// The field is a function (not a method) that may be changed to point to
	// a custom error handler. What happens after Usage is called depends
	// on the ErrorHandling setting; for the command line, this defaults
	// to ExitOnError, which exits the program after calling Usage.
	Usage func()

	name   string
	parsed bool

	actual map[string]*Flag
	formal map[string]*Flag
	short  map[rune]*Flag

	args          []string // arguments after flags
	errorHandling ErrorHandling
	output        io.Writer // nil means stderr; use out() accessor
}

// A Flag represents the state of a flag.
type Flag struct {
	Name     string // name as it appears on command line
	Short    rune   // short flag as it appears on command line
	Usage    string // help message
	Value    Value  // value as set
	DefValue string // default value (as text); for usage message
}

// sortFlags returns the flags as a slice in lexicographical sorted order.
func sortFlags(flags map[string]*Flag) []*Flag {
	list := make(sort.StringSlice, len(flags))

	i := 0
	for name := range flags {
		list[i] = name
		i++
	}

	list.Sort()

	result := make([]*Flag, len(list))
	for i, name := range list {
		result[i] = flags[name]
	}

	return result
}

// Output returns the destination for usage and error messages. os.Stderr is returned if
// output was not set or was set to nil.
func (f *FlagSet) Output() io.Writer {
	if f.output == nil {
		return os.Stderr
	}
	return f.output
}

// Name returns the name of the flag set.
func (f *FlagSet) Name() string {
	return f.name
}

// ErrorHandling returns the error handling behavior of the flag set.
func (f *FlagSet) ErrorHandling() ErrorHandling {
	return f.errorHandling
}

// SetOutput sets the destination for usage and error messages.
// If output is nil, os.Stderr is used.
func (f *FlagSet) SetOutput(output io.Writer) {
	f.output = output
}

// VisitAll visits the flags in lexicographical order, calling fn for each.
// It visits all flags, even those not set.
func (f *FlagSet) VisitAll(fn func(*Flag)) {
	for _, flag := range sortFlags(f.formal) {
		fn(flag)
	}
}

// VisitAll visits the command-line flags in lexicographical order, calling
// fn for each. It visits all flags, even those not set.
func VisitAll(fn func(*Flag)) {
	CommandLine.VisitAll(fn)
}

// Visit visits the flags in lexicographical order, calling fn for each.
// It visits only those flags that have been set.
func (f *FlagSet) Visit(fn func(*Flag)) {
	for _, flag := range sortFlags(f.actual) {
		fn(flag)
	}
}

// Visit visits the command-line flags in lexicographical order, calling fn
// for each. It visits only those flags that have been set.
func Visit(fn func(*Flag)) {
	CommandLine.Visit(fn)
}

// Lookup returns the Flag structure of the named flag, returning nil if none exists.
func (f *FlagSet) Lookup(name string) *Flag {
	if flag, ok := f.formal[name]; ok {
		return flag
	}

	// if the first rune in a string is the same length as a string in bytes,
	// then we have a single rune as the string.
	if r, n := utf8.DecodeRuneInString(name); n == len(name) {
		return f.short[r]
	}

	return nil
}

// Lookup returns the Flag structure of the named command-line flag,
// returning nil if none exists.
func Lookup(name string) *Flag {
	return CommandLine.Lookup(name)
}

// Set sets the value of the named flag.
func (f *FlagSet) Set(name, value string) error {
	flag, ok := f.formal[name]
	if !ok {
		r, n := utf8.DecodeRuneInString(name)

		// if the length of a string in bytes is > the length of the first rune, then it’s multiple-runes.
		if n < len(name) {
			return fmt.Errorf("no such flag --%v", name)
		}

		flag, ok = f.short[r]
		if !ok {
			return fmt.Errorf("no such flag -%v", name)
		}
	}

	if err := flag.Value.Set(value); err != nil {
		return err
	}

	if f.actual == nil {
		f.actual = make(map[string]*Flag)
	}

	f.actual[name] = flag
	return nil
}

// Set sets the value of the named command-line flag.
func Set(name, value string) error {
	return CommandLine.Set(name, value)
}

// isZeroValue guesses whether the string represents the zero
// value for a flag. It is not accurate but in practice works OK.
func isZeroValue(flag *Flag, value string) bool {
	// Build a zero value of the flag's Value type, and see if the
	// result of calling its String method equals the value passed in.
	// This works unless the Value type is itself an interface type.
	typ := reflect.TypeOf(flag.Value)
	var z reflect.Value

	if typ.Kind() == reflect.Ptr {
		z = reflect.New(typ.Elem())
	} else {
		z = reflect.Zero(typ)
	}

	if value == z.Interface().(Value).String() {
		return true
	}

	switch value {
	case "false", "", "0":
		return true
	}

	return false
}

// UnquoteUsage extracts a back-quoted name from the usage
// string for a flag and returns it and the un-quoted usage.
// Given "a `name` to show" it returns ("name", "a name to show").
// If there are no back quotes, the name is an educated guess of the
// type of the flag's value, or the empty string if the flag is boolean.
func UnquoteUsage(flag *Flag) (name string, usage string) {
	type valueTyper interface {
		ValueType() string
	}

	// Look for a back-quoted name, but avoid the strings package.
	usage = flag.Usage
	for i, r := range usage {
		if r == '`' || r == '·' {
			l := 1
			if r == '·' {
				l = 2
			}

			for j, r2 := range usage[i+l:] {
				if r2 == r {
					j += i + l
					name = usage[i+l : j]
					usage = usage[:i] + name + usage[j+l:]
					return name, usage
				}
			}
			break // Only one backquote or middot; use type name.
		}
	}

	// No explicit name, so use type if we can find one.
	name = "value"
	switch f := flag.Value.(type) {
	case boolFlag:
		name = ""
	case valueTyper:
		name = f.ValueType()
	case *durationValue:
		name = "duration"
	case *float64Value:
		name = "float"
	case *intValue, *int64Value:
		name = "int"
	case *stringValue:
		name = "string"
	case *uintValue, *uint64Value:
		name = "uint"
	}

	return
}

// PrintDefaults prints, to standard error unless configured otherwise, the
// default values of all defined command-line flags in the set. See the
// documentation for the global function PrintDefaults for more information.
func (f *FlagSet) PrintDefaults() {
	f.VisitAll(func(flag *Flag) {
		// This function is rarely called, as such, we can afford to
		// just += a string, and keep things simple.
		var s string

		_, n := utf8.DecodeRuneInString(flag.Name)

		switch {
		// special case: flag.Name is one rune long, so it is only short
		case n == len(flag.Name):
			s = " -" + flag.Name

		default:
			s = " --" + flag.Name

			if flag.Short != 0 {
				s += " | -" + string(flag.Short)
			}
		}

		name, usage := UnquoteUsage(flag)
		if len(name) > 0 {
			s += " <" + name + ">"
		}

		// If the flag signature is longer than a tab, put its usage on the next line
		// BUG: we want to use the display width, not the rune-length (there are zero-width runes)
		if utf8.RuneCountInString(s) > 7 {
			// Four spaces before the tab triggers good alignment
			// for both 4- and 8-space tab stops.
			s += "\n    "
		}

		s += "\t" + strings.Replace(usage, "\n", "\n    \t", -1)

		// TODO: we should be checking here to make sure the funcValue.value is non zero
		if f, isFunc := flag.Value.(*funcValue); isFunc {
			if f.value != "" {
				// put quotes on the value
				s += fmt.Sprintf(" (default %q)", f.value)
			}

		} else if !isZeroValue(flag, flag.DefValue) {
			if _, ok := flag.Value.(*stringValue); ok {
				// put quotes on the value
				s += fmt.Sprintf(" (default %q)", flag.DefValue)
			} else {
				s += fmt.Sprintf(" (default %v)", flag.DefValue)
			}
		}
		fmt.Fprint(f.Output(), s, "\n")
	})
}

// PrintDefaults prints, to standard error unless configured otherwise,
// a usage message showing the default settings of all defined
// command-line flags.
// For an integer-valued flag named "flag" with short-name "f", the default output has the form:
//	--flag | -f <int>
//		usage-message-for-flag (default 42)
// For an integer-valued flag named "f" (automatically short) the default output has the form:
//	-f <int>
//		usage-message-for-f (default 42)
// The usage message will appear on a separate line for anything but
// a bool flag with a one-byte name. For bool flags, the type is
// omitted and if the flag name is one byte the usage message appears
// on the same line. The parenthetical default is omitted if the
// default is the zero value for the type. The listed type, here int,
// can be changed by placing a back-quoted name in the flag's usage
// string; the first such item in the message is taken to be a parameter
// name to show in the message and the back quotes are stripped from
// the message when displayed. For instance, given
//	flag.String("I", "", "search `directory` for include files")
// the output will be
//	-I <directory>
//		search directory for include files.
func PrintDefaults() {
	CommandLine.PrintDefaults()
}

// defaultUsage is the default function to print a usage message.
func (f *FlagSet) defaultUsage() {
	if f.name == "" {
		fmt.Fprintf(f.Output(), "Usage:\n")
	} else {
		fmt.Fprintf(f.Output(), "Usage of %s:\n", f.name)
	}
	f.PrintDefaults()
}

// NOTE: Usage is not just defaultUsage(CommandLine)
// because it serves (via godoc flag Usage) as the example
// for how to write your own usage function.

// Usage prints a usage message documenting all defined command-line flags
// to CommandLine's output, which by default is os.Stderr.
// It is called when an error occurs while parsing flags.
// The function is a variable that may be changed to point to a custom function.
// By default it prints a simple header and calls PrintDefaults; for details about the
// format of the output and how to control it, see the documentation for PrintDefaults.
// Custom usage functions may choose to exit the program; by default exiting
// happens anyway as the command line's error handling strategy is set to
// ExitOnError.
var Usage = func() {
	fmt.Fprintf(CommandLine.Output(), "Usage of %s:\n", os.Args[0])
	PrintDefaults()
}

// NFlag returns the number of flags that have been set.
func (f *FlagSet) NFlag() int { return len(f.actual) }

// NFlag returns the number of command-line flags that have been set.
func NFlag() int { return len(CommandLine.actual) }

// Arg returns the i'th argument. Arg(0) is the first remaining argument
// after flags have been processed. Arg returns an empty string if the
// requested element does not exist.
func (f *FlagSet) Arg(i int) string {
	if i < 0 || i >= len(f.args) {
		return ""
	}
	return f.args[i]
}

// Arg returns the i'th command-line argument. Arg(0) is the first remaining argument
// after flags have been processed. Arg returns an empty string if the
// requested element does not exist.
func Arg(i int) string {
	return CommandLine.Arg(i)
}

// NArg is the number of arguments remaining after flags have been processed.
func (f *FlagSet) NArg() int { return len(f.args) }

// NArg is the number of arguments remaining after flags have been processed.
func NArg() int { return len(CommandLine.args) }

// Args returns the non-flag arguments.
func (f *FlagSet) Args() []string { return f.args }

// Args returns the non-flag command-line arguments.
func Args() []string { return CommandLine.args }

func (f *FlagSet) set(flag *Flag, name string) {
	if len(name) < 1 {
		return
	}

	if f.formal == nil {
		f.formal = make(map[string]*Flag)
	}

	_, alreadythere := f.formal[name]
	if alreadythere {
		var msg string

		if f.name != "" {
			msg = f.name + " "
		}

		msg += fmt.Sprintf("longflag redefined: %q", name)

		fmt.Fprintln(f.Output(), msg)
		panic(msg) // Happens only if flags are declared with identical names
	}

	f.formal[name] = flag
}

func (f *FlagSet) setShort(flag *Flag, name rune) {
	if name < 1 {
		return
	}

	if f.short == nil {
		f.short = make(map[rune]*Flag)
	}

	_, alreadythere := f.short[name]
	if alreadythere {
		var msg string

		if f.name != "" {
			msg = f.name + " "
		}

		msg += fmt.Sprintf("shortflag redefined: %q", string(name))

		fmt.Fprintln(f.Output(), msg)
		panic(msg) // Happens only if flags are declared with identical names
	}

	f.short[name] = flag
}

// Copy copies an existing flag into this FlagSet.
// This uses the already given name, short, usage, and default.
// It will panic if you attempt to copy a Flag into a FlagSet where the name or short name already exist.
//	fs := flag.NewFlagSet("example", flag.ExitOnError)
//	fs.Copy(flag.Lookup("output"))
func (f *FlagSet) Copy(flag *Flag) {
	f.set(flag, flag.Name)
	f.setShort(flag, flag.Short)
}

// CopyFrom does a lookup of the flagname on the given FlagSet, and the Copies that flag into this Flagset.
// It will panic if you attempt to copy a Flag into a FlagSet where the name or short name already exist.
//	fs := flag.NewFlagSet("example", flag.ExitOnError)
//	fs.CopyFrom(flag.CommandLine, "output")
func (f *FlagSet) CopyFrom(from *FlagSet, name string) {
	f.Copy(from.Lookup(name))
}

// Var defines a flag with the specified name and usage string. The type and
// value of the flag are represented by the first argument, of type Value, which
// typically holds a user-defined implementation of Value. For instance, the
// caller could create a flag that turns a comma-separated string into a slice
// of strings by giving the slice the methods of Value; in particular, Set would
// decompose the comma-separated string into the slice.
func (f *FlagSet) Var(value Value, name string, usage string, options ...Option) error {
	// Remember the default value is a string; it won't change.
	// Well, unless a WithDefault Option is passed…
	flag := &Flag{
		Name:     name,
		Usage:    usage,
		Value:    value,
		DefValue: value.String(),
	}

	// if name is only one rune long, then alias it as a short-flag name.
	if r, n := utf8.DecodeRuneInString(name); n == len(name) {
		flag.Short = r
	}

	for _, opt := range options {
		// during initialization we discard all reversing functionality
		_, err := opt(flag)
		if err != nil {
			return err
		}
	}

	f.set(flag, name)
	f.setShort(flag, flag.Short)
	return nil
}

// Var defines a flag with the specified name and usage string. The type and
// value of the flag are represented by the first argument, of type Value, which
// typically holds a user-defined implementation of Value. For instance, the
// caller could create a flag that turns a comma-separated string into a slice
// of strings by giving the slice the methods of Value; in particular, Set would
// decompose the comma-separated string into the slice.
func Var(value Value, name string, usage string, options ...Option) error {
	return CommandLine.Var(value, name, usage, options...)
}

// failf prints to standard error a formatted error and usage message and
// returns the error.
func (f *FlagSet) failf(format string, a ...interface{}) error {
	err := fmt.Errorf(format, a...)
	fmt.Fprintln(f.Output(), err)
	f.usage()
	return err
}

// usage calls the Usage method for the flag set if one is specified,
// or the appropriate default usage function otherwise.
func (f *FlagSet) usage() {
	if f.Usage == nil {
		f.defaultUsage()
	} else {
		f.Usage()
	}
}

func (f *FlagSet) undefinedShortFlag(name rune) (bool, error) {
	if name == '?' {
		// special case for nice help message.
		f.usage()
		return false, ErrHelp
	}

	return false, f.failf("flag provided but not defined: -%c", name)
}

func (f *FlagSet) undefinedFlag(name string) (bool, error) {
	if name == "help" || name == "?" {
		// special case for nice help message.
		f.usage()
		return false, ErrHelp
	}

	return false, f.failf("flag provided but not defined: --%s", name)
}

// parseOne parses one flag. It reports whether a flag was seen.
func (f *FlagSet) parseOne() (bool, error) {
	if len(f.args) < 1 {
		return false, nil
	}

	// we’re accepting em-dash and en-dash as aliases for "--", so
	// we need to convert things into runes to deal with things properly.
	r := []rune(f.args[0])

	// if the argument is only one character long, it cannot be
	// any form of flag whatsoever, so we stop parsing.
	if len(r) < 2 {
		return false, nil
	}

	var long bool

	switch r[0] {
	case '–', '—':
		long = true
	case '-':
		// for now, assume short form flag
	default:
		return false, nil
	}

	numMinuses := 1

	// this allows [em-dash, en-dash], hyphen, but… eh, whatever
	if r[1] == '-' { // oh, it is a long form flag after all
		long = true
		numMinuses++
	}

	// if we're all minuses, terminate flag parsing, and pass over this terminator
	if len(r) <= numMinuses {
		f.args = f.args[1:]
		return false, nil
	}

	switch r[numMinuses] {
	// we’re not supposed to be having any dashes at this point.
	case '-', '–', '—':
		return false, f.failf("bad flag syntax: %s", string(r))
	// likewise, no '='.
	case '=':
		return false, f.failf("no flag name given: %s", string(r))
	}

	// ok, _now_ we have the name we’re going to use.
	name := string(r[numMinuses:])

	// ok, it’s a flag, so shift the arguments
	f.args = f.args[1:]

	var hasValue bool
	var value string

	// now, let’s check to see if we have an argument
	if i := strings.IndexByte(name, '='); i > 0 {
		value = name[i+1:]
		hasValue = true
		name = name[0:i]
	}

	if long {
		flag, ok := f.formal[name] // BUG: [explanation needed]
		if !ok {
			return f.undefinedFlag(name)
		}

		return f.doFlag(flag, name, value, hasValue)
	}

	return f.parseShort(name, value, hasValue)
}

func (f *FlagSet) parseShort(name, value string, hasValue bool) (bool, error) {
	// we need to not only range over the runes of name, but we
	// need to be able to ensure we know we’re on the last rune
	// of the series. And then, we need to potentially convert the rune
	// series into a value for a flag. (à la -m"git message here")
	r := []rune(name)
	last := len(r) - 1

	for i, n := range r {
		flag, ok := f.short[n] // BUG: [explanation needed]
		if !ok {
			return f.undefinedShortFlag(n)
		}

		// easy, -…n[=value]
		if i == last {
			// support things like: cut -d= -f1
			if hasValue && value == "" {
				return f.doFlag(flag, string(n), "=", true)
			}

			return f.doFlag(flag, string(n), value, hasValue)
		}

		// allowed: -…n…[=value], if flag.IsBoolFlag() == true
		if fv, ok := flag.Value.(boolFlag); ok && fv.IsBoolFlag() {
			// hasValue == true to be extra sure about preventing
			//  accidentally pulling the next argument in as the value.
			return f.doFlag(flag, string(n), "true", true)
		}

		// not allowed: -…n…=value, if flag requires a value
		if hasValue {
			return false, f.failf("bad flag format -%c requires an argument, but does not appear at the end: -%s=%s", n, name, value)
		}

		// allowed: -…n"value here, like -m flag in git"
		return f.doFlag(flag, string(n), string(r[i+1:]), true)
	}

	panic("unreachable code reached")
}

func (f *FlagSet) doFlag(flag *Flag, name string, value string, hasValue bool) (bool, error) {
	if f.actual == nil {
		f.actual = make(map[string]*Flag)
	}
	f.actual[name] = flag

	var prefix = "--"
	// if the first rune is the length of the whole string, then RuneCount == 1
	if _, n := utf8.DecodeRuneInString(name); n == len(name) {
		prefix = "-"
	}

	if fv, ok := flag.Value.(boolFlag); ok && fv.IsBoolFlag() {
		// special case: doesn't need an arg
		if !hasValue {
			value = "true"
		}

		if err := fv.Set(value); err != nil {
			return false, f.failf("invalid boolean value %q for %s%s: %v", value, prefix, name, err)
		}

		return true, nil
	}

	// It must have a value, which might be the next argument.
	if !hasValue {
		if len(f.args) < 1 {
			return false, f.failf("flag needs an argument: %s%s", prefix, name)
		}

		// value is the next arg
		value, f.args = f.args[0], f.args[1:]
	}

	if err := flag.Value.Set(value); err != nil {
		return false, f.failf("invalid value %q for flag %s%s: %v", value, prefix, name, err)
	}

	return true, nil
}

// Parse parses flag definitions from the argument list, which should not
// include the command name. Must be called after all flags in the FlagSet
// are defined and before flags are accessed by the program.
// The return value will be ErrHelp if --help or -? were set but not defined.
func (f *FlagSet) Parse(arguments []string) error {
	f.parsed = true
	f.args = arguments

	if len(f.args) < 1 {
		return nil
	}

	for {
		seen, err := f.parseOne()
		if seen {
			continue
		}
		if err == nil {
			break
		}

		switch f.errorHandling {
		case ContinueOnError:
			return err
		case ExitOnError:
			os.Exit(2)
		case PanicOnError:
			panic(err)
		}
	}

	return nil
}

// Parsed reports whether f.Parse has been called.
func (f *FlagSet) Parsed() bool {
	return f.parsed
}

// Parse parses the command-line flags from os.Args[1:]. Must be called
// after all flags are defined and before flags are accessed by the program.
func Parse() {
	// Ignore errors; CommandLine is set for ExitOnError.
	CommandLine.Parse(os.Args[1:])
}

// Parsed reports whether the command-line flags have been parsed.
func Parsed() bool {
	return CommandLine.Parsed()
}

// CommandLine is the default set of command-line flags, parsed from os.Args.
// The top-level functions such as BoolVar, Arg, and so on are wrappers for the
// methods of CommandLine.
var CommandLine = NewFlagSet(os.Args[0], ExitOnError)

func init() {
	// Override generic FlagSet default Usage with call to global Usage.
	// Note: This is not CommandLine.Usage = Usage,
	// because we want any eventual call to use any updated value of Usage,
	// not the value it has when this line is run.
	CommandLine.Usage = func() {
		Usage()
	}
}

// NewFlagSet returns a new, empty flag set with the specified name and
// error handling property.
func NewFlagSet(name string, errorHandling ErrorHandling) *FlagSet {
	f := &FlagSet{
		name:          name,
		errorHandling: errorHandling,
	}
	f.Usage = f.defaultUsage
	return f
}

// Init sets the name and error handling property for a flag set.
// By default, the zero FlagSet uses an empty name and the
// ContinueOnError error handling policy.
func (f *FlagSet) Init(name string, errorHandling ErrorHandling) {
	f.name = name
	f.errorHandling = errorHandling
}
